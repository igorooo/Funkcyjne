Hello from /home/qivi/.vscode/extensions/jaredly.reason-vscode-1.2.4/bin.native.linux
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json", "globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","refmt":"","lispRefmt":"","format_width":"80","per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/qivi/Funkcyjne/lec7zad.ml","languageId":"ocaml","version":1,"text":"\nmodule type QUEUE_FUN =\nsig\n  type 'a t\n  exception Empty of string\n  val empty: unit -> 'a t\n  val enqueue: 'a * 'a t -> 'a t\n  val dequeue: 'a t -> 'a t\n  val first: 'a t -> 'a\n  val isEmpty: 'a t -> bool\nend;;\n\nmodule Queue : QUEUE_FUN = \nstruct\n  type 'a t = 'a list \n  exception Empty of string\n  \n  let empty() = []\n  let enqueue (e, q) = match q with\n                        | [] -> [e]\n                        | l -> l@[e]\n  let dequeue  = function\n                | hd::tl -> tl\n                | [] -> []\n  let first = function\n                | hd::tl -> hd\n                |[] -> raise (Empty \"empty queue\")\n  let isEmpty q = q = []\n\nend ;;\n\nlet qq = Queue.empty ();;\n\nlet qq1 = Queue.enqueue (1, qq) ;;\nlet qq2 = Queue.enqueue (2, qq1) ;;\nlet qq3 = Queue.enqueue (3, qq2) ;;\n\nQueue.first qq1 ;;\nlet qq22 = Queue.dequeue qq2;;\nQueue.first qq33;;\nQueue.first qq2;;\nQueue.dequeue qq;;\nQueue.first qq22;;\n\nQueue.isEmpty qq;;\n\n\nmodule DQueue : QUEUE_FUN = \nstruct\n  type 'a t = 'a list * 'a list\n  exception Empty of string\n  \n  let empty() = [],[]\n  let enqueue (e, q) = match q with\n                        | [],[] -> [e],[]\n                        | [],l2 -> List.rev (e::l2), []\n                        | l1, l2 -> l1, e::l2\n  let dequeue  = function\n                | [],[] -> [],[]\n                | [], l2 -> let hd::tl = (List.rev l2) in tl,[]\n                | [felem],l2 -> (List.rev l2), []\n                | hd::tl,l2 -> tl,l2\n  let first = function\n                | hd::tl,l2 -> hd\n                |[],[] -> raise (Empty \"empty queue\")\n  let isEmpty q = q = ([],[])\nend ;;\n\n\n\nlet qq = DQueue.empty ();;\n\nlet qq1 = DQueue.enqueue (1, qq) ;;\nlet qq2 = DQueue.enqueue (2, qq1) ;;\nlet qq3 = DQueue.enqueue (3, qq2) ;;\n\nDQueue.first qq1 ;;\nlet qq22 = DQueue.dequeue qq2;;\nDQueue.first qq33;;\nDQueue.first qq2;;\nDQueue.dequeue qq;;\nDQueue.first qq22;;\n\nDQueue.isEmpty qq;;\n\n\n\n(*ZAD2*)\n\nmodule type QUEUE_MUT =\nsig\n\ttype 'a t\n\t(* The type of queues containing elements of type ['a]. *)\n\texception Empty of string\n\t(* Raised when [first q] is applied to an empty queue [q]. *)\n\texception Full of string\n\t(* Raised when [enqueue(x,q)] is applied to a full queue [q]. *)\n\tval empty: int -> 'a t\n\t(* [empty n] returns a new queue of length [n], initially empty. *)\n\tval enqueue: 'a * 'a t -> unit\n\t(* [enqueue (x,q)] adds the element [x] at the end of a queue [q]. *)\n\tval dequeue: 'a t -> unit\n\t(* [dequeue q] removes the first element in queue [q] *)\n\tval first: 'a t -> 'a\n\t(* [first q] returns the first element in queue [q] without removing it  *)\n\t(* from the queue, or raises [Empty] if the queue is empty.              *)\n\tval isEmpty: 'a t -> bool\n\t(* [isEmpty q] returns [true] if queue [q] is empty, otherwise returns   *)\n\t(* [false].                                                              *)\n\tval isFull: 'a t -> bool\n(* [isFull q] returns [true] if queue [q] is full, otherwise returns       *)\n(* [false].                                                                *)\nend\n\nmodule type QUEUE_MUT =\nsig\n\ttype 'a t\n\t(* The type of queues containing elements of type ['a]. *)\n\texception Empty of string\n\t(* Raised when [first q] is applied to an empty queue [q]. *)\n\texception Full of string\n\t(* Raised when [enqueue(x,q)] is applied to a full queue [q]. *)\n\tval empty: int -> 'a t\n\t(* [empty n] returns a new queue of length [n], initially empty. *)\n\tval enqueue: 'a * 'a t -> unit\n\t(* [enqueue (x,q)] adds the element [x] at the end of a queue [q]. *)\n\tval dequeue: 'a t -> unit\n\t(* [dequeue q] removes the first element in queue [q] *)\n\tval first: 'a t -> 'a\n\t(* [first q] returns the first element in queue [q] without removing it  *)\n\t(* from the queue, or raises [Empty] if the queue is empty.              *)\n\tval isEmpty: 'a t -> bool\n\t(* [isEmpty q] returns [true] if queue [q] is empty, otherwise returns   *)\n\t(* [false].                                                              *)\n\tval isFull: 'a t -> bool\n(* [isFull q] returns [true] if queue [q] is full, otherwise returns       *)\n(* [false].                                                                *)\nend ;;\n\n\nmodule CArrQueue : QUEUE_MUT =\nstruct\n\n  type 'a t = {mutable size: int; mutable f: int; mutable r: int; mutable arr: 'a option array}\n  exception Empty of string\n  exception Full of string\n\n  let empty s = {size = s +1; f = 0; r = 0; arr = Array.make (s+1) None}\n\n  let isEmpty q = q.r = q.f\n  let isFull q = (q.r +1)mod q.size = q.f\n\n  let enqueue (elem, q) = if isFull q then raise (Full \"full queue\")\n                       else (Array.set q.arr q.r (Some elem); q.r <- ((q.r +1)mod q.size);)\n  \n  let dequeue q = if isEmpty q then ()\n                  else (Array.set q.arr q.f None; q.f <- ((q.f +1)mod q.size);)\n\n  let first q = if isEmpty q then raise (Empty \"empty queue\")\n                else let Some temp = Array.get q.arr q.f in temp\nend ;;\n\nlet cq1 = CArrQueue.empty 4;;\n\nCArrQueue.isFull cq1;;\nCArrQueue.isEmpty cq1;;\n\nCArrQueue.enqueue (1,cq1);; \n\nCArrQueue.isEmpty cq1;;\n\nCArrQueue.enqueue (2,cq1);;\n\nCArrQueue.enqueue (3,cq1);;\n\nCArrQueue.enqueue (4,cq1);;\n\nCArrQueue.isFull cq1;;\n\nCArrQueue.first cq1;;\n\nCArrQueue.dequeue cq1;;\n\nCArrQueue.first cq1;;\n\nCArrQueue.dequeue cq1;;\n\nCArrQueue.first cq1;;\n\nCArrQueue.dequeue cq1;;\n\nCArrQueue.first cq1;;\n\nCArrQueue.dequeue cq1;;\n\nCArrQueue.first cq1;;\n\nCArrQueue.isEmpty cq1;;\n\n\n# CArrQueue.isFull cq1;;\n- : bool = false\n# CArrQueue.isEmpty cq1;;\n- : bool = true\n# CArrQueue.enqueue (1,cq1);;\n- : unit = ()\n# CArrQueue.isEmpty cq1;;\n- : bool = false\n# CArrQueue.enqueue (2,cq1);;\n- : unit = ()\n# CArrQueue.enqueue (3,cq1);;\n- : unit = ()\n# CArrQueue.enqueue (4,cq1);;\n- : unit = ()\n# CArrQueue.isFull cq1;;\n- : bool = true\n# CArrQueue.first cq1;;\n- : int = 1\n# CArrQueue.dequeue cq1;;\n- : unit = ()\n# CArrQueue.first cq1;;\n- : int = 2\n# CArrQueue.dequeue cq1;;\n- : unit = ()\n# CArrQueue.first cq1;;\n- : int = 3\n# CArrQueue.dequeue cq1;;\n- : unit = ()\n# CArrQueue.first cq1;;\n- : int = 4\n# CArrQueue.isEmpty cq1;;\n- : bool = false\n# CArrQueue.dequeue cq1;;\n- : unit = ()\n# CArrQueue.first cq1;;\nException: CArrQueue.Empty \"empty queue\".\n# CArrQueue.isEmpty cq1;;\n- : bool = true\n\n\nmodule Queue : QUEUE_FUN = \nstruct\n  type 'a t = { mutable l: 'a list }\n  exception Empty of string\n  \n  let empty() = { l = [] }\n  let enqueue (e, q) = q.l <- e::q.l; q\n  let dequeue q = match List.rev q.l with\n                  | hd::tl -> q.l <- List.rev tl; q\n                  |[] -> q\n  let first q = match List.rev q.l with\n                | hd::tl -> hd\n                |[] -> raise (Empty \"empty queue\")\n  let isEmpty q = q.l = []\n\nend ;;\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/qivi/Funkcyjne/lec7zad.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/qivi/Funkcyjne/lec7zad.ml"},"range":{"start":{"line":7,"character":27},"end":{"line":7,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/qivi/Funkcyjne/lec7zad.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.000953674316406ms
Sending response {"id": 3, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/qivi/Funkcyjne/lec7zad.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/qivi/Funkcyjne/lec7.ml","languageId":"ocaml","version":1,"text":"module M =\n( struct \n    type buffer = int ref\n    let create() = ref 0\n    let add x = incr x\n    let get x = if !x>0 then (decr x;!x) else failwith \"Empty\"\n  end\n: sig\n    type buffer\n    val create : unit -> buffer\n    val add : buffer -> unit\n    val get : buffer -> int\n  end\n) ;;\n\n\nlet a  = M.create ();;\n\nM.add a;;\n\nM.get a;;\n\nlet str = \"alamakota\";;\nlet str1 = \"alamakota\";;\nstr = str1;;"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/qivi/Funkcyjne/lec7.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00214576721191ms
Sending response {"id": 4, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/qivi/Funkcyjne/lec7.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.000953674316406ms
Sending response {"id": 5, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/qivi/Funkcyjne/lec7.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.000953674316406ms
Sending response {"id": 6, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/qivi/Funkcyjne/lec7.ml"},"range":{"start":{"line":24,"character":12},"end":{"line":24,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00214576721191ms
Sending response {"id": 7, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":8,"method":"shutdown","params":null}
Sending response {"id": 8, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"exit","params":null}
Got exit! Terminating loop
Finished
